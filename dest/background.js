function instrument(details) {
  let filter = browser.webRequest.filterResponseData(details.requestId)
  let decoder = new TextDecoder('utf-8')
  let encoder = new TextEncoder()

  filter.ondata = event => {
    let str = decoder.decode(event.data, { stream: true })
    if (!str.includes('generated by Svelte v3.')) {
      filter.write(event.data)
      filter.disconnect()
      return
    }

    str = str
      .replace(
        /class\s+(\w+?)\s+extends\s+SvelteComponent\s+{\n\s*constructor\(options\)\s+{\n\s*super\(\);/g,
        "$&\nthis.tagName = '$1';"
      )
      .replace(
        /(append|insert|mount_component|each_blocks\[i\]\.m)\((.+?)\);/g,
        '$1($2, ctx);'
      )
      // Hack since firefox doesn't support lookbehinds
      .replace(
        'mount_component(component, options.target, options.anchor, ctx);',
        'mount_component(component, options.target, options.anchor);'
      )
      .replace(
        'function append(target, node) {',
        'function append(target, node, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertHTMLElement", { detail: { target, node, ctx } }));'
      )
      .replace(
        'function insert(target, node, anchor) {',
        'function insert(target, node, anchor, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertHTMLElement", { detail: { target, node, anchor, ctx } }));'
      )
      .replace(
        'function mount_component(component, target, anchor) {',
        'function mount_component(component, target, anchor, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertComponent", { detail: { target, component, anchor, ctx } }));'
      )
      .replace(
        /(function create_each_block(?:_\d+)?\(ctx\) {[^]+?m\(target, anchor)\) {/g,
        '$1, parentCtx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertEachBlock", { detail: { target, anchor, ctx: parentCtx, block: ctx } }));'
      )
      .replace(
        'function detach(node) {',
        '$&\ndocument.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node } }));'
      )
      .replace(
        'function destroy(component, detaching) {',
        '$&\nif (detaching) document.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node: component.$$$$.ctx } }));'
      )
      .replace(
        /function create_each_block(?:_\d+)?\(ctx\) {[^]+?d\(detaching\) {/g,
        '$&\ndocument.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node: ctx } }));'
      )
      .replace(
        'function make_dirty(component, key) {',
        'window.make_dirty = $&'
      )
      .replace(
        /function update\(\$\$\) {[^]+?}/,
        '$&\ndocument.dispatchEvent(new CustomEvent("SvelteUpdate", { detail: { $$$$ } }));'
      )
    filter.write(encoder.encode(str))
    filter.disconnect()
  }

  return {}
}

const toolsPorts = new Map()
const pagePorts = new Map()

browser.runtime.onConnect.addListener(port => {
  if (port.sender.url == browser.runtime.getURL('/devtools/panel.html')) {
    port.onMessage.addListener(handleToolsMessage)
  } else {
    port.onMessage.addListener(handlePageMessage)
    pagePorts.set(port.sender.tab.id, port)
  }
})

function handleToolsMessage(msg, port) {
  if (msg.type == 'init') {
    setup(msg.tabId, port)
  }

  const page = pagePorts.get(msg.tabId)
  if (page) page.postMessage(msg)
}

function handlePageMessage(msg, port) {
  const tools = toolsPorts.get(port.sender.tab.id)
  if (tools) tools.postMessage(msg)
}

function attachScript(tabId, changed) {
  if (changed.status != 'loading' || !changed.url) return

  toolsPorts.get(tabId).postMessage({ type: 'init' })
  browser.tabs.executeScript(tabId, {
    file: '/content.js',
    runAt: 'document_start'
  })
}

function setup(tabId, port) {
  toolsPorts.set(tabId, port)
  port.onDisconnect.addListener(() => {
    toolsPorts.delete(tabId)
    pagePorts.delete(tabId)
    browser.tabs.onUpdated.removeListener(attachScript)
    browser.webRequest.onBeforeRequest.removeListener(instrument)
  })

  browser.tabs.onUpdated.addListener(attachScript, {
    properties: ['status'],
    tabId
  })
  browser.webRequest.onBeforeRequest.addListener(
    instrument,
    { urls: ['*://*/*'], types: ['script'], tabId },
    ['blocking']
  )
}
