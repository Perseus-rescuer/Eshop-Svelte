function instrument(details) {
  let filter = browser.webRequest.filterResponseData(details.requestId)
  let decoder = new TextDecoder('utf-8')
  let encoder = new TextEncoder()

  filter.ondata = event => {
    let str = decoder.decode(event.data, { stream: true })
    if (!str.includes('generated by Svelte v3.')) {
      filter.write(event.data)
      filter.disconnect()
      return
    }

    str = str
      .replace(
        /class\s+(\w+?)\s+extends\s+SvelteComponent\s+{\n\s*constructor\(options\)\s+{\n\s*super\(\);/g,
        "$&\nthis.tagName = '$1';"
      )
      .replace(
        /(append|insert|mount_component|each_blocks\[i\]\.m)\((.+?)\);/g,
        '$1($2, ctx);'
      )
      // Hack since firefox doesn't support lookbehinds
      .replace(
        'mount_component(component, options.target, options.anchor, ctx);',
        'mount_component(component, options.target, options.anchor);'
      )
      .replace(
        'function append(target, node) {',
        'function append(target, node, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertHTMLElement", { detail: { target, node, ctx } }));'
      )
      .replace(
        'function insert(target, node, anchor) {',
        'function insert(target, node, anchor, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertHTMLElement", { detail: { target, node, anchor, ctx } }));'
      )
      .replace(
        'function mount_component(component, target, anchor) {',
        'function mount_component(component, target, anchor, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertComponent", { detail: { target, component, anchor, ctx } }));'
      )
      .replace(
        /(function create_each_block(?:_\d+)?\(ctx\) {[^]+?m\(target, anchor)\) {/g,
        '$1, parentCtx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertEachBlock", { detail: { target, anchor, ctx: parentCtx, block: ctx } }));'
      )
      .replace(
        'function detach(node) {',
        '$&\ndocument.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node } }));'
      )
      .replace(
        'function destroy(component, detaching) {',
        '$&\nif (detaching) document.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node: component.$$$$.ctx } }));'
      )
      .replace(
        /function create_each_block(?:_\d+)?\(ctx\) {[^]+?d\(detaching\) {/g,
        '$&\ndocument.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node: ctx } }));'
      )
      .replace(
        'function make_dirty(component, key) {',
        'window.make_dirty = $&'
      )
    filter.write(encoder.encode(str))
    filter.disconnect()
  }

  return {}
}

browser.webRequest.onBeforeRequest.addListener(
  instrument,
  { urls: ['*://*/*'], types: ['script'] },
  ['blocking']
)

const toolsPorts = new Map()
const pagePorts = new Map()

function handleToolsMessage(msg, port) {
  if (msg.type == 'init') {
    toolsPorts.set(msg.id, port)
  }

  const page = pagePorts.get(msg.id)
  if (page) page.postMessage(msg)
}

function handlePageMessage(msg, port) {
  const tools = toolsPorts.get(port.sender.tab.id)
  if (tools) tools.postMessage(msg)
}

browser.runtime.onConnect.addListener(port => {
  if (port.sender.tab) {
    pagePorts.set(port.sender.tab.id, port)
    port.onMessage.addListener(handlePageMessage)
  } else {
    port.onMessage.addListener(handleToolsMessage)
  }
})
