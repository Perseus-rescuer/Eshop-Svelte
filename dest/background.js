function instrument(str) {
  if (!str.includes('generated by Svelte v3.')) {
    return false
  }

  return (
    str
      .replace(
        /class\s+(\w+?)\s+extends\s+SvelteComponent\s+{\n\s*constructor\(options\)\s+{\n\s*super\(\);/g,
        "$&\nthis.tagName = '$1';"
      )
      .replace(
        /(append|insert|mount_component|each_blocks\[i\]\.m)\((.+?)\);/g,
        '$1($2, ctx);'
      )
      // Hack since firefox doesn't support lookbehinds
      .replace(
        'mount_component(component, options.target, options.anchor, ctx);',
        'mount_component(component, options.target, options.anchor);'
      )
      .replace(
        'function append(target, node) {',
        'function append(target, node, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertHTMLElement", { detail: { target, node, ctx } }));'
      )
      .replace(
        'function insert(target, node, anchor) {',
        'function insert(target, node, anchor, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertHTMLElement", { detail: { target, node, anchor, ctx } }));'
      )
      .replace(
        'function mount_component(component, target, anchor) {',
        'function mount_component(component, target, anchor, ctx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertComponent", { detail: { target, component, anchor, ctx } }));'
      )
      .replace(
        /(function create_each_block(?:_\d+)?\(ctx\) {[^]+?m\(target, anchor)\) {/g,
        '$1, parentCtx) {\ndocument.dispatchEvent(new CustomEvent("SvelteInsertEachBlock", { detail: { target, anchor, ctx: parentCtx, block: ctx } }));'
      )
      .replace(
        'function detach(node) {',
        '$&\ndocument.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node } }));'
      )
      .replace(
        'function destroy(component, detaching) {',
        '$&\nif (detaching) document.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node: component.$$$$.ctx } }));'
      )
      .replace(
        /function create_each_block(?:_\d+)?\(ctx\) {[^]+?d\(detaching\) {/g,
        '$&\ndocument.dispatchEvent(new CustomEvent("SvelteRemoveNode", { detail: { node: ctx } }));'
      )
      .replace(
        'function make_dirty(component, key) {',
        'window.make_dirty = $&'
      )
      .replace(
        /function update\(\$\$\) {[^]+?}/,
        '$&\ndocument.dispatchEvent(new CustomEvent("SvelteUpdate", { detail: { $$$$ } }));'
      )
  )
}

const toolsPorts = new Map()
const pagePorts = new Map()

chrome.runtime.onConnect.addListener(port => {
  if (port.sender.url == chrome.runtime.getURL('/devtools/panel.html')) {
    port.onMessage.addListener(handleToolsMessage)
  } else {
    port.onMessage.addListener(handlePageMessage)
    port.onDisconnect.addListener(port => pagePorts.delete(port.sender.tab.id))
    pagePorts.set(port.sender.tab.id, port)
  }
})

function handleToolsMessage(msg, port) {
  if (msg.type == 'init') setup(msg.tabId, port)

  const page = pagePorts.get(msg.tabId)
  if (page) page.postMessage(msg)
}

function handlePageMessage(msg, port) {
  if (msg.type == 'loadInline') loadInlineScripts()

  const tools = toolsPorts.get(port.sender.tab.id)
  if (tools) tools.postMessage(msg)
}

function attachScript(tabId, changed) {
  if (!toolsPorts.has(tabId) || changed.status != 'loading') return

  toolsPorts.get(tabId).postMessage({ type: 'init' })
  chrome.tabs.executeScript(tabId, {
    // In chrome load `content.js` which injects `privilegedContent.js`
    // directy into the page
    file: chrome.app ? '/content.js' : '/privilegedContent.js',
    runAt: 'document_start'
  })
}

let inlineScripts = []
async function loadInlineScripts() {
  inlineScripts.forEach(o =>
    o.then(script => {
      chrome.tabs.executeScript(script.tabId, {
        code: `
          const tag = Array.from(document.scripts)
            .find(o => o.src == "${script.url}")
          const newTag = document.createElement('script')
          newTag.text = "${script.source
            .replace(/"/g, '\\"')
            .replace(/\n/g, '\\n')}"
          if (tag == null)
            document.head.append(newTag)
          else
            tag.parentNode.replaceChild(newTag, tag)
        `,
        runAt: 'document_start'
      })
    })
  )
  inlineScripts = []
}

function queueInlineScript(tabId, url) {
  inlineScripts.push(
    fetch(url)
      .then(o => o.text())
      .then(o => ({ tabId, url, source: instrument(o) }))
  )
}

function interceptRequest(details) {
  if (details.method != 'GET' || details.frameId != 0) return

  // Chrome doesn't have response filters. Queue script to be inlined after
  // content script is executed instead
  if (!chrome.webRequest.filterResponseData) {
    queueInlineScript(details.tabId, details.url)
    return { cancel: true }
  }

  const filter = chrome.webRequest.filterResponseData(details.requestId)
  const decoder = new TextDecoder('utf-8')
  const encoder = new TextEncoder()

  filter.ondata = event => {
    const str = decoder.decode(event.data, { stream: true })
    const instrumented = instrument(str)
    if (!instrumented) {
      filter.write(event.data)
      filter.disconnect()
      return
    }

    filter.write(encoder.encode(instrumented))
    filter.disconnect()
  }

  return {}
}

function setup(tabId, port) {
  toolsPorts.set(tabId, port)
  port.onDisconnect.addListener(() => {
    toolsPorts.delete(tabId)
    pagePorts.delete(tabId)
    chrome.tabs.onUpdated.removeListener(attachScript)
    chrome.webRequest.onBeforeRequest.removeListener(interceptRequest)
  })

  chrome.tabs.onUpdated.addListener(attachScript)
  chrome.webRequest.onBeforeRequest.addListener(
    interceptRequest,
    { urls: ['*://*/*'], types: ['script'], tabId },
    ['blocking']
  )
}
